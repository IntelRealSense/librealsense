<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Intel® RealSense™ Cross Platform API: rs2::pipeline Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Intel® RealSense™ Cross Platform API
   </div>
   <div id="projectbrief">Intel Realsense Cross-platform API</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacers2.html">rs2</a></li><li class="navelem"><a class="el" href="classrs2_1_1pipeline.html">pipeline</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classrs2_1_1pipeline-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">rs2::pipeline Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="rs__pipeline_8hpp_source.html">rs_pipeline.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aae168079fd9b73927185efb7a0556dad"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrs2_1_1pipeline.html#aae168079fd9b73927185efb7a0556dad">pipeline</a> (<a class="el" href="classrs2_1_1context.html">context</a> ctx=<a class="el" href="classrs2_1_1context.html">context</a>())</td></tr>
<tr class="separator:aae168079fd9b73927185efb7a0556dad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a858f263affc80f76c5b7c9f062309ede"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrs2_1_1pipeline__profile.html">pipeline_profile</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrs2_1_1pipeline.html#a858f263affc80f76c5b7c9f062309ede">start</a> ()</td></tr>
<tr class="separator:a858f263affc80f76c5b7c9f062309ede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9647d29312105af555e5c734f64aee63"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrs2_1_1pipeline__profile.html">pipeline_profile</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrs2_1_1pipeline.html#a9647d29312105af555e5c734f64aee63">start</a> (const <a class="el" href="classrs2_1_1config.html">config</a> &amp;<a class="el" href="classrs2_1_1config.html">config</a>)</td></tr>
<tr class="separator:a9647d29312105af555e5c734f64aee63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc5d033471567a6cadd98bf190c66ef4"><td class="memTemplParams" colspan="2">template&lt;class S &gt; </td></tr>
<tr class="memitem:acc5d033471567a6cadd98bf190c66ef4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classrs2_1_1pipeline__profile.html">pipeline_profile</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrs2_1_1pipeline.html#acc5d033471567a6cadd98bf190c66ef4">start</a> (S callback)</td></tr>
<tr class="separator:acc5d033471567a6cadd98bf190c66ef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e807d630f3ca0404884ffc42993d440"><td class="memTemplParams" colspan="2">template&lt;class S &gt; </td></tr>
<tr class="memitem:a2e807d630f3ca0404884ffc42993d440"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classrs2_1_1pipeline__profile.html">pipeline_profile</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrs2_1_1pipeline.html#a2e807d630f3ca0404884ffc42993d440">start</a> (const <a class="el" href="classrs2_1_1config.html">config</a> &amp;<a class="el" href="classrs2_1_1config.html">config</a>, S callback)</td></tr>
<tr class="separator:a2e807d630f3ca0404884ffc42993d440"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a142ee1adb798f9a03f86eb90895dd8a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrs2_1_1pipeline.html#a142ee1adb798f9a03f86eb90895dd8a5">stop</a> ()</td></tr>
<tr class="separator:a142ee1adb798f9a03f86eb90895dd8a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac77cdd3d2f4ce1e85ea30d475743cec8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrs2_1_1frameset.html">frameset</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrs2_1_1pipeline.html#ac77cdd3d2f4ce1e85ea30d475743cec8">wait_for_frames</a> (unsigned int timeout_ms=<a class="el" href="rs__config_8h.html#a9df60b60a2c445a3d4283a9d491190ff">RS2_DEFAULT_TIMEOUT</a>) const</td></tr>
<tr class="separator:ac77cdd3d2f4ce1e85ea30d475743cec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9069a979fd9e1e28881b945a6aec1b79"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrs2_1_1pipeline.html#a9069a979fd9e1e28881b945a6aec1b79">poll_for_frames</a> (<a class="el" href="classrs2_1_1frameset.html">frameset</a> *f) const</td></tr>
<tr class="separator:a9069a979fd9e1e28881b945a6aec1b79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac26eb27ff433e3b0b3c144b814300a7a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrs2_1_1pipeline.html#ac26eb27ff433e3b0b3c144b814300a7a">try_wait_for_frames</a> (<a class="el" href="classrs2_1_1frameset.html">frameset</a> *f, unsigned int timeout_ms=<a class="el" href="rs__config_8h.html#a9df60b60a2c445a3d4283a9d491190ff">RS2_DEFAULT_TIMEOUT</a>) const</td></tr>
<tr class="separator:ac26eb27ff433e3b0b3c144b814300a7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b51c8a6bde3067f5efbfa63c125332f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrs2_1_1pipeline__profile.html">pipeline_profile</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrs2_1_1pipeline.html#a5b51c8a6bde3067f5efbfa63c125332f">get_active_profile</a> () const</td></tr>
<tr class="separator:a5b51c8a6bde3067f5efbfa63c125332f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac121c039ba2561ee3bb71c02e4cb8a72"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrs2_1_1pipeline.html#ac121c039ba2561ee3bb71c02e4cb8a72">operator std::shared_ptr&lt; rs2_pipeline &gt;</a> () const</td></tr>
<tr class="separator:ac121c039ba2561ee3bb71c02e4cb8a72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bde635553c539bf5ed6e23aa641e4d4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrs2_1_1pipeline.html#a1bde635553c539bf5ed6e23aa641e4d4">pipeline</a> (std::shared_ptr&lt; <a class="el" href="rs__types_8h.html#ad54a014210e511b9f28470267ebf5c90">rs2_pipeline</a> &gt; ptr)</td></tr>
<tr class="separator:a1bde635553c539bf5ed6e23aa641e4d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a4053ba4f62bbf3aede52f13f348a8af2"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrs2_1_1pipeline.html#a4053ba4f62bbf3aede52f13f348a8af2">config</a></td></tr>
<tr class="separator:a4053ba4f62bbf3aede52f13f348a8af2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The pipeline simplifies the user interaction with the device and computer vision processing modules. The class abstracts the camera configuration and streaming, and the vision modules triggering and threading. It lets the application focus on the computer vision output of the modules, or the device output data. The pipeline can manage computer vision modules, which are implemented as a processing blocks. The pipeline is the consumer of the processing block interface, while the application consumes the computer vision interface. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aae168079fd9b73927185efb7a0556dad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae168079fd9b73927185efb7a0556dad">&#9670;&nbsp;</a></span>pipeline() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">rs2::pipeline::pipeline </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrs2_1_1context.html">context</a>&#160;</td>
          <td class="paramname"><em>ctx</em> = <code><a class="el" href="classrs2_1_1context.html">context</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a pipeline for processing data from a single device. The caller can provide a context created by the application, usually for playback or testing purposes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>The context allocated by the application. Using the platform context by default. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1bde635553c539bf5ed6e23aa641e4d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bde635553c539bf5ed6e23aa641e4d4">&#9670;&nbsp;</a></span>pipeline() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">rs2::pipeline::pipeline </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="rs__types_8h.html#ad54a014210e511b9f28470267ebf5c90">rs2_pipeline</a> &gt;&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a5b51c8a6bde3067f5efbfa63c125332f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b51c8a6bde3067f5efbfa63c125332f">&#9670;&nbsp;</a></span>get_active_profile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrs2_1_1pipeline__profile.html">pipeline_profile</a> rs2::pipeline::get_active_profile </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the active device and streams profiles, used by the pipeline. The pipeline streams profiles are selected during <code><a class="el" href="classrs2_1_1pipeline.html#a858f263affc80f76c5b7c9f062309ede">start()</a></code>. The method returns a valid result only when the pipeline is active - between calls to <code><a class="el" href="classrs2_1_1pipeline.html#a858f263affc80f76c5b7c9f062309ede">start()</a></code> and <code><a class="el" href="classrs2_1_1pipeline.html#a142ee1adb798f9a03f86eb90895dd8a5">stop()</a></code>. After <code><a class="el" href="classrs2_1_1pipeline.html#a142ee1adb798f9a03f86eb90895dd8a5">stop()</a></code> is called, the pipeline doesn't own the device, thus, the pipeline selected device may change in subsequent activations.</p>
<dl class="section return"><dt>Returns</dt><dd>The actual pipeline device and streams profile, which was successfully configured to the streaming device on start. </dd></dl>

</div>
</div>
<a id="ac121c039ba2561ee3bb71c02e4cb8a72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac121c039ba2561ee3bb71c02e4cb8a72">&#9670;&nbsp;</a></span>operator std::shared_ptr&lt; rs2_pipeline &gt;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">rs2::pipeline::operator std::shared_ptr&lt; <a class="el" href="rs__types_8h.html#ad54a014210e511b9f28470267ebf5c90">rs2_pipeline</a> &gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9069a979fd9e1e28881b945a6aec1b79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9069a979fd9e1e28881b945a6aec1b79">&#9670;&nbsp;</a></span>poll_for_frames()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool rs2::pipeline::poll_for_frames </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrs2_1_1frameset.html">frameset</a> *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check if a new set of frames is available and retrieve the latest undelivered set. The frames set includes time-synchronized frames of each enabled stream in the pipeline. The method returns without blocking the calling thread, with status of new frames available or not. If available, it fetches the latest frames set. Device frames, which were produced while the function wasn't called, are dropped. To avoid frame drops, this method should be called as fast as the device frame rate. The application can maintain the frames handles to defer processing. However, if the application maintains too long history, the device may lack memory resources to produce new frames, and the following calls to this method shall return no new frames, until resources become available.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">f</td><td>Frames set handle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if new set of time synchronized frames was stored to f, false if no new frames set is available </dd></dl>

</div>
</div>
<a id="a858f263affc80f76c5b7c9f062309ede"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a858f263affc80f76c5b7c9f062309ede">&#9670;&nbsp;</a></span>start() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrs2_1_1pipeline__profile.html">pipeline_profile</a> rs2::pipeline::start </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start the pipeline streaming with its default configuration. The pipeline streaming loop captures samples from the device, and delivers them to the attached computer vision modules and processing blocks, according to each module requirements and threading model. During the loop execution, the application can access the camera streams by calling <code><a class="el" href="classrs2_1_1pipeline.html#ac77cdd3d2f4ce1e85ea30d475743cec8">wait_for_frames()</a></code> or <code><a class="el" href="classrs2_1_1pipeline.html#a9069a979fd9e1e28881b945a6aec1b79">poll_for_frames()</a></code>. The streaming loop runs until the pipeline is stopped. Starting the pipeline is possible only when it is not started. If the pipeline was started, an exception is raised.</p>
<dl class="section return"><dt>Returns</dt><dd>The actual pipeline device and streams profile, which was successfully configured to the streaming device. </dd></dl>

</div>
</div>
<a id="a9647d29312105af555e5c734f64aee63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9647d29312105af555e5c734f64aee63">&#9670;&nbsp;</a></span>start() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrs2_1_1pipeline__profile.html">pipeline_profile</a> rs2::pipeline::start </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrs2_1_1config.html">config</a> &amp;&#160;</td>
          <td class="paramname"><em>config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start the pipeline streaming according to the configuraion. The pipeline streaming loop captures samples from the device, and delivers them to the attached computer vision modules and processing blocks, according to each module requirements and threading model. During the loop execution, the application can access the camera streams by calling <code><a class="el" href="classrs2_1_1pipeline.html#ac77cdd3d2f4ce1e85ea30d475743cec8">wait_for_frames()</a></code> or <code><a class="el" href="classrs2_1_1pipeline.html#a9069a979fd9e1e28881b945a6aec1b79">poll_for_frames()</a></code>. The streaming loop runs until the pipeline is stopped. Starting the pipeline is possible only when it is not started. If the pipeline was started, an exception is raised. The pipeline selects and activates the device upon start, according to configuration or a default configuration. When the <a class="el" href="classrs2_1_1config.html">rs2::config</a> is provided to the method, the pipeline tries to activate the config <code>resolve()</code> result. If the application requests are conflicting with pipeline computer vision modules or no matching device is available on the platform, the method fails. Available configurations and devices may change between config <code>resolve()</code> call and pipeline start, in case devices are connected or disconnected, or another application acquires ownership of a device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">config</td><td>A <a class="el" href="classrs2_1_1config.html">rs2::config</a> with requested filters on the pipeline configuration. By default no filters are applied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The actual pipeline device and streams profile, which was successfully configured to the streaming device. </dd></dl>

</div>
</div>
<a id="acc5d033471567a6cadd98bf190c66ef4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc5d033471567a6cadd98bf190c66ef4">&#9670;&nbsp;</a></span>start() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrs2_1_1pipeline__profile.html">pipeline_profile</a> rs2::pipeline::start </td>
          <td>(</td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start the pipeline streaming with its default configuration. The pipeline captures samples from the device, and delivers them to the provided frame callback. Starting the pipeline is possible only when it is not started. If the pipeline was started, an exception is raised. When starting the pipeline with a callback both <code><a class="el" href="classrs2_1_1pipeline.html#ac77cdd3d2f4ce1e85ea30d475743cec8">wait_for_frames()</a></code> and <code><a class="el" href="classrs2_1_1pipeline.html#a9069a979fd9e1e28881b945a6aec1b79">poll_for_frames()</a></code> will throw exception.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>Stream callback, can be any callable object accepting <a class="el" href="classrs2_1_1frame.html">rs2::frame</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The actual pipeline device and streams profile, which was successfully configured to the streaming device. </dd></dl>

</div>
</div>
<a id="a2e807d630f3ca0404884ffc42993d440"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e807d630f3ca0404884ffc42993d440">&#9670;&nbsp;</a></span>start() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrs2_1_1pipeline__profile.html">pipeline_profile</a> rs2::pipeline::start </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrs2_1_1config.html">config</a> &amp;&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start the pipeline streaming according to the configuraion. The pipeline captures samples from the device, and delivers them to the provided frame callback. Starting the pipeline is possible only when it is not started. If the pipeline was started, an exception is raised. When starting the pipeline with a callback both <code><a class="el" href="classrs2_1_1pipeline.html#ac77cdd3d2f4ce1e85ea30d475743cec8">wait_for_frames()</a></code> and <code><a class="el" href="classrs2_1_1pipeline.html#a9069a979fd9e1e28881b945a6aec1b79">poll_for_frames()</a></code> will throw exception. The pipeline selects and activates the device upon start, according to configuration or a default configuration. When the <a class="el" href="classrs2_1_1config.html">rs2::config</a> is provided to the method, the pipeline tries to activate the config <code>resolve()</code> result. If the application requests are conflicting with pipeline computer vision modules or no matching device is available on the platform, the method fails. Available configurations and devices may change between config <code>resolve()</code> call and pipeline start, in case devices are connected or disconnected, or another application acquires ownership of a device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">config</td><td>A <a class="el" href="classrs2_1_1config.html">rs2::config</a> with requested filters on the pipeline configuration. By default no filters are applied. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>Stream callback, can be any callable object accepting <a class="el" href="classrs2_1_1frame.html">rs2::frame</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The actual pipeline device and streams profile, which was successfully configured to the streaming device. </dd></dl>

</div>
</div>
<a id="a142ee1adb798f9a03f86eb90895dd8a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a142ee1adb798f9a03f86eb90895dd8a5">&#9670;&nbsp;</a></span>stop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void rs2::pipeline::stop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Stop the pipeline streaming. The pipeline stops delivering samples to the attached computer vision modules and processing blocks, stops the device streaming and releases the device resources used by the pipeline. It is the application's responsibility to release any frame reference it owns. The method takes effect only after <code><a class="el" href="classrs2_1_1pipeline.html#a858f263affc80f76c5b7c9f062309ede">start()</a></code> was called, otherwise an exception is raised. </p>

</div>
</div>
<a id="ac26eb27ff433e3b0b3c144b814300a7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac26eb27ff433e3b0b3c144b814300a7a">&#9670;&nbsp;</a></span>try_wait_for_frames()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool rs2::pipeline::try_wait_for_frames </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrs2_1_1frameset.html">frameset</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>timeout_ms</em> = <code><a class="el" href="rs__config_8h.html#a9df60b60a2c445a3d4283a9d491190ff">RS2_DEFAULT_TIMEOUT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac77cdd3d2f4ce1e85ea30d475743cec8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac77cdd3d2f4ce1e85ea30d475743cec8">&#9670;&nbsp;</a></span>wait_for_frames()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrs2_1_1frameset.html">frameset</a> rs2::pipeline::wait_for_frames </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>timeout_ms</em> = <code><a class="el" href="rs__config_8h.html#a9df60b60a2c445a3d4283a9d491190ff">RS2_DEFAULT_TIMEOUT</a></code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Wait until a new set of frames becomes available. The frames set includes time-synchronized frames of each enabled stream in the pipeline. In case of different frame rates of the streams, the frames set include a matching frame of the slow stream, which may have been included in previous frames set. The method blocks the calling thread, and fetches the latest unread frames set. Device frames, which were produced while the function wasn't called, are dropped. To avoid frame drops, this method should be called as fast as the device frame rate. The application can maintain the frames handles to defer processing. However, if the application maintains too long history, the device may lack memory resources to produce new frames, and the following call to this method shall fail to retrieve new frames, until resources become available.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout_ms</td><td>Max time in milliseconds to wait until an exception will be thrown </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Set of time synchronized frames, one from each active stream </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a4053ba4f62bbf3aede52f13f348a8af2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4053ba4f62bbf3aede52f13f348a8af2">&#9670;&nbsp;</a></span>config</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classrs2_1_1config.html">config</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>C:/jenkins_sys_rsbuild/workspace/LRS_doxygen_pipeline/source/include/librealsense2/hpp/<a class="el" href="rs__pipeline_8hpp_source.html">rs_pipeline.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
